## 图片懒加载

mint-ui 
依托 Vue.js 高效的组件化方案，Mint UI 做到了轻量化。即使全部引入，压缩后的文件体积也仅有 ~30kb (JS + CSS) gzip。
```
import Vue from 'vue' //引入插件
import { Lazyload } from 'mint-ui';//引入插件
Vue.use(Lazyload);// 注册插件
src-->v-lazy
 <img v-lazy="item">
```
Lazyload
仅仅请求想要看到的图片：
判断图片进出界面的时间：

## 项目中防抖和节流(性能优化)的使用、讲一下他们两个的区别
throttle(节流) 和 debounce(防抖) 是性能优化的利器。
lodash插件里面封装函数的防抖和节流业务【闭包+延时器】
```
import throttle from "lodash/throttle";
//用于修改组件实例身上的currentIndex的属性值
    //当用户鼠标移入到h3身上的时候就会立即触发一次
    changeIndex: throttle(function (index) {
      //修改当前currentIndex索引值
      //函数节流:在20MS时间之内只能执行一次
      this.currentIndex = index;
    }, 20),
```
函数节流(throttle) 是指一定时间内 js 方法只运行一次。把频繁的操作变为少量的操作，使浏览器有充分时间解析代码。不会重复触发回调，只有在大于这个时间才会触发回调。
1. 射击游戏
2. 购物车数字加，一秒内只能加1
3. 轮播图
4. 搜索联想(keyup)

函数防抖(debounce) 前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次。

1. 每次 resize/scroll 触发统计事件
2. 搜索文本只验证最后一次。文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）


二级菜单栏：
正常情况(用户慢慢操作)：鼠标进入，每一个一级分类h3，都会触发鼠标进入事件
非正常情况(用户操作很快)：
全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分h3触发了，这是因为用户的行为过快，导致浏览器未反应过来。而当前回调函数中有大量业务有可能出现卡顿现象
非正常情况(事件触发非常频繁)，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部有计算，那么很可能出现浏览器卡顿）

## flex自适应

在伸缩盒中，初始的行为是，弹性的物件将参照容器里面的空间的大小，缩小和分布物件之间的空间。通过更改flex-grow和 flex-shrink的值，你可以指示在物件遇到周围有更多或者更少的空间的情况下，你所期望的物件表现。
flex弹性布局：首先，我们需要选择将哪些元素将设置为柔性的盒子。我们需要给这些 flexible 元素的父元素 display 设置一个特定值。
less main.js全局挂载
```
import less from 'less'
Vue.use(less)
```
首页的抢购模块为例：
整个抢购模块用section元素包围，其中包含
左边是倒计时仪器，
另：流式布局(宽度设置为百分比的形式)
## 移动端界面的适配
项目中用vw进行适配：使用视口单位vw来实现响应式排版
移动端界面书写时，若把宽度高度或字体大小全部写死，存在的问题是同样大小的字体，或者一个盒子模型，在大屏手机上看起来会偏小。做了适配，则大屏幕显示内容大一点，小屏幕显示小一点。
需求：
1. 在不同分辨率的手机上，页面看起来是自适应的。整体效果看起来很和谐。
2. 主要是关注字体，宽高，间距，图片大小等
3. 使用rem做单位，而不是传统的px
步骤1：
设置viewport
为何需要这个？因为移动端浏览器倾向于在它们的视口宽度上说谎。
```
<meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
```
width：设置视口的宽度，这里是设备屏幕的宽度
initial-scale：页面初始的缩放值，设置为零也就是不缩放
maximum-scale：允许用户的最大缩放值
minimum-scale：允许用户的最小缩放值
user-scalable：是否允许用户缩放
步骤2：
引入写好的css预处理器fz.less
步骤3：
计算vw大小
另：元素添加 font-size 属性，并且动态改写 font-size 的值
设备像素比(device pixel ratio)设备像素比 = 物理像素 / 设备独立像素。移动端默认的视口宽度为980px，那么像素比的计算就是980/设备的物理像素宽度，求出来的就是移动端1物理像素，要渲染多少css像素
### rem、em、vw、vh
rem ：
相对于根元素html的font-size的px大小，例如font-size是16px，就等于1rem，能够做到响应式布局，即通过匹配不同设备屏幕大小，设置其html的font-size的值。
em：
相对于当前对象内文本的字体尺寸（参考物是父元素的font-size），如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸
特点：
  1. em的值并不是固定的
  2. em会继承父级元素的字体大小
vw：
vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100，假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）
vh：
vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100，假如浏览器的高度为500px，那么1vh就等于5px（500px/100）
百分比：1、对于普通定位元素就是我们理解的父元素
2、对于position: absolute;的元素是相对于已定位的父元素
3、对于position: fixed;的元素是相对于ViewPort（可视窗口）
### 媒介查询
允许我们运行一系列测试，例如用户的屏幕是否大于某个宽度或者某个分辨率，并将CSS选择性地适应用户的需要应用在样式化页面上。
## flex属性的三个值分别对应着什么
flex：是flex-grow(放大比例)、flex-shrink(缩小比例)、flex-basis(分配空间)的缩写，默认值0(即使存在剩余空间，项目也不放大) 1(空间不足将缩小，若是0，空间不足不缩小) auto(项目的原本大小)。 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间
## 箭头函数和普通函数区别
箭头函数相当于匿名函数，并且简化了函数定义。
1.this方面：
普通函数内部的this，默认指向window，严格模式下指向undefined；
箭头函数内部的this，与上一级作用域中的this指向同一个地方。
1. 如果参数只有一个，则小括号可以省略；
2. 函数体若只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果；
3. 箭头函数this指向声明时所在作用域下的this的值 即window
4. 箭头函数不能作为构造函数实例化，即不能使用new
5. 不能使用arguments，解决：取而代之需要用展开运算符解决
6. 箭头函数没有原型属性
## BFC
一个BFC区域只包含其子元素，不包括其子元素的子元素.不同的BFC区域之间是相互独立的，互不影响的。利用这个特性我们可以让不同BFC区域之间的布局不产生影响.
## 登录的前后端实现：token、Vue 导航守卫、axios 拦截器等
将token的值存储在state中
## 怎么解决跨域
axios