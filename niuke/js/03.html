<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*
    AngularJS使用了mvc进行web开发，其中控制层一般用什么语言来定义
    js

    有关 JavaScript 常见事件的触发情况
    
    onkeydown    某个键盘按键被按下。 
    onkeypress：某个键盘的键被按下或按住
    onkeyup        某个键盘按键被松开。

    onchange：用户改变域的内容
    onselect    文本被选中。

    onblur：失去焦点
    onfocus: 元素获得焦点。
    onload：一张页面或一幅图像完成加载。

    onmousedown：某个鼠标按键被按下
    onmouseup    鼠标按键被松开。
    onmousemove    鼠标被移动。
    onmouseover    鼠标移到某元素之上。
    onmouseout    鼠标从某元素移开。

    onsubmit    确认按钮被点击。
    onreset    重置按钮被点击。
    */


    /*
    concat() 数组的连接 sort() 数组的排序 reverse() 数组的倒序  length是数组的属性 通过Array.length获取数组的长度
    */


    /*
    下面对this对象的理解,哪些是正确的 
    如果有new关键字，this指向new出来的那个对象； 
    在事件中，this指向触发这个事件的对象， 特殊的是，IE中的attachEvent中的this总是指向全局对象Window；
    1.函数调用时， 严格模式("use strict")下this是undefined的，非严格模式下this为window 2.以方法调用时，指向调用该方法的对象 3.使用new创建一个对象时，
    指向该对象 4.call,apply ,bind可以改变this指向 区别，传参不同
    */

    /*
    如果想要获取整个网页文档中h1标签的个数，可以通过 
    document.getElementById();
    document.getElementsByTagName();
    document.getElementsByName();
    document.getElementsByClassName();
    记住ID具有唯一性所以只能返回element，className、Name、TagName都是可以重复的所以需要返回elements就行了。
    */



    /*   var foo = 'Hello';
      (function () {
        var bar = 'World';
        alert(foo + bar);
      })(); */
    /*
    IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的  JavaScript 函数。
    (function () {
    statements
    })();
    这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，
    这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。
    第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。
    */
    /*  alert(foo + bar); */





    /* var i = 100;
    function foo () {
      bbb: try {
        // try catch 还有finally代码块中 有return时 的执行情况
        // try...catch语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。
        // try语句包含了由一个或者多个语句组成的try块, 和至少一个catch块或者一个finally块的其中一个，
        // 或者两个兼有，
        // （finally子句在try块和catch块之后执行但是在下一个try声明之前执行。
        // 无论是否有异常抛出或捕获它总是执行。)
        // 如果try语句没有使用finally，则返回try语句中return的东西，
        // 函数try...catch语句之外的return 就不执行了
        // 如果try语句后面有finally，try中的return不会跳出函数,因为一定要进入finally语句
        // 函数try...finally语句之外的return 就不执行了
        console.log("position1");//打印position1
        return i++;// 继续执行return右边的代码，此时i++为100，i为101
      }
      finally {// 只要有finally，不管try语句里写啥（return,break之类的失效），都会执行finally语句
        break bbb;// 跳出bbb标签代码块
        // 跳出try...finally后，因为finally中没有return，故可执行后续代码
        //如果finally中有return，则无法执行后续代码了
        // break语句用于跳出 switch语句 或者 循环语句（ for 、for..in、while、do...while） 
        // 语法：break;
        // 当break语句用于switch语句时，会跳出switch代码块，终止执行switch代码。
        // 当break语句用于循环语句时，会跳出整个循环，不再执行后续剩余的循环。
        // 注意break与continue的区别：continue会跳出本轮循环，继续执行后续剩余的循环
      }
      console.log("position2");//打印position2
      return i;
    }
    foo(); */



    /* let a = 1;
    let obj = {
      x: 1
    }
    delete a;
    delete obj.x;
    delete 2;
    console.log(a);
    console.log(obj.x);
    console.log(2); */
    /*
    delete 操作符用于删除对象的某个属性；如果没有指向这个属性的引用，那它最终会被释放。
    delete 删除的是对象的属性
    */

    /*  执行以下程序，当用户在prompt输入框中输入0时，输出结果为 */
    /* var num = prompt('请输入分母:')
    try {
      console.log('a'); // 打印
      value = 0 / num; // NaN 不会出错
      console.log('b'); // 打印
    }
    catch (e) {
      console.log('c');// 跳过
    }
    finally {
      console.log('d'); // 打印
    } */
    /*  任何数值除以0都会导致错误而终止程序执行,但是在 JavaScript 中，会返回出NaN，不影响后面程序
try...catch 用来捕获try{}代码段中可能会发生的异常，catch子句包含try块中抛出异常时要执行的语句。
如果在try块中有任何一个语句（或者从try块中调用的函数）抛出异常，控制立即转向catch子句。
（如果在try块中没有异常抛出，会跳过catch子句）。*/

    var uname = "window";
    var object = {
      uname: "object",
      fun: function () {
        console.log(this.uname); // 第一个执行
        return function () {
          console.log(this.uname); // 第二个执行
        }
      }
    }
    object.fun()();
    // object window

    /*
    第一个函数是由object对象调用，this指向object对象 第二个是普通函数调用，指向window
    先执行object.fun(), 此时的this指向函数的调用的者，也就是object对象本身。
    */

    /*   javascript中实现跨域的方式总结
  第一种方式：jsonp请求；jsonp的原理是利用<script>标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有<img>.
  第二种方式：document.domain；这种方式用在主域名相同子域名不同的跨域访问中
  第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
  第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
  第五种方式：CORS；CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
  第六种方式：Web Sockets；web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。
  
   */
  </script>
</body>

</html>